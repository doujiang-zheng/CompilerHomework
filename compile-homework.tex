%!TEX program = xelatex
\documentclass[UTF8]{ctexart}
\usepackage{algorithm}
%\PassOptionsToPackage{noend}{algpseudocode} % 不显示循环、条件的结尾
\usepackage{algpseudocode}
\usepackage{algorithmicx}
\usepackage{amsmath}
\usepackage{color}
\usepackage{xcolor}
\definecolor{keywordcolor}{rgb}{0.8, 0.1, 0.5}
\usepackage{graphicx}
\usepackage{listings}
\lstset{breaklines}%这条命令可以让LaTeX自动将长的代码行换行排版
\lstset{extendedchars=false}%这一条命令可以解决代码跨页时，章节标题，页眉等汉字不显示的问题
\lstset{language=C++, %用于设置语言为C++
	keywordstyle=\color{keywordcolor} \bfseries, 
	identifierstyle=,
	basicstyle=\ttfamily, 
	commentstyle=\color{blue} \textit,
	stringstyle=\ttfamily, 
	%numbers=left,
	showstringspaces=false,
	%frame=shadowbox, %边框
	captionpos=b
}

\makeatletter %使\section中的内容左对齐
\renewcommand{\section}{\@startsection{section}{1}{0mm}
	{-\baselineskip}{0.5\baselineskip}{\bf\leftline}}
\makeatother

\author{913106840530郑铜亚}
\title{编译原理课程设计报告}

\begin{document}
	\maketitle
	\newpage
	
	\section{问题描述} % (fold)
	\label{sec:probelm_descrption}
	\paragraph{} % (fold)
	Task $1$: Create a lexical analysis program,
	which supports analyzing regular grammar.
	% paragraph paragraph_name (end)
	\paragraph{} % (fold)
	You must use DFA(Determinstic Finite Automata) or
	NFA(Non-determinstic Finite Automata) to implement
	this program. The inputs of the program are a text
	document including a set of productions of 3 degree
	grammar(the regular grammar) and a source code text
	document contains a set of strings to be recognized.
	The ouput of the program is a token table which 
	consists of 5 types token: key words, identifier, 
	const, limiter abd operator.
	% paragraph  (end)
	\paragraph{} % (fold)
	Task $2$: Create a phaser analysis program, which 
	uses LL(1) method or LR(1) method.
	% paragraph  (end)
	\paragraph{} % (fold)
	The inputs of the program are a text document including
	a set of productions of the 2 degree grammar(context free
	grammar) and the token table generated by Task $1$. The 
	output of the program is YES or NO. i.e., the source code
	string accords with this 2 degree grammar or the source code
	string does not accord with this 2 degree grammar.
	% paragraph  (end)
	% section section_name (end)
	
	\section{文法改造与数据结构} % (fold)
	\label{sec:grammar_modify_and_data_structure}
	\subsection{文法改造} % (fold)
	\label{sub:grammar_modify}
	\paragraph{} % (fold)
	为了便于处理输入文法，特要求给定输入中先给出全部非终结符，以$\#\#\#$结尾；
	接着输入全部终结符，以$\#\#\#$结尾；接下来是全部的产生式，每条产生式以$\#\#\#$
	标识输入结束。
	% paragraph  (end)
	\subsubsection{三型文法} % (fold)
	\paragraph{} % (fold)
	三型文法，分为左线性文法与右线性文法，不妨，本设计只处理右线性文法。
	% paragraph  (end)
	\paragraph{} % (fold)
	右线性文法共三种类型输入，处理如下：
	% paragraph  (end)
	\begin{enumerate}
		\item $A \rightarrow \varepsilon$，则输入为 A EPSILON FINAL；
		\item $A \rightarrow a$，则输入为 A a FINAL；
		\item $A \rightarrow aS$，则输入为 A a S。
	\end{enumerate}
	% subsubsection _ (end)
	\subsubsection{二型文法} % (fold)
	\paragraph{} % (fold)
	二型文法，又称上下文无关文法，形如$\alpha \rightarrow \beta$，则
	$\alpha \in V_N$且$\beta \in (V_T \cup V_N)^*$，同上
	% paragraph  (end)
	\begin{enumerate}
		\item $A \rightarrow \varepsilon$，则输入为 A EPSILON；
		\item $A \rightarrow aSbCd$，则输入为 A a S b C d。
	\end{enumerate}
	% subsubsection _ (end)
	% subsection subsection_name (end)
	\subsection{数据结构} % (fold)
	\label{sub:data_structure}
	\subsubsection{Adjacency List} % (fold)
	\label{ssub:adjacency_list}
	\paragraph{} % (fold)
	虽然大部分NFA边都是字符，为保持扩展性，本设计使用string统一表示$V_N$、$V_T$，
	同时为简化图的表示，使用$V_N$的编号而非string来作为邻接表的元素。
	% paragraph  (end)
	\begin{lstlisting}
	struct list_node
	{
	// when turning nfa to dfa, a flag is needed.
	//long vis;
	string edge;
	long next_id;
	// Actually, whether nfa or dfa, node represents a state.
	// Only edge represents real string-pattern.
	// char next_string[MAXSIZE];
	};
	\end{lstlisting}
	% subsubsection  (end)
	\subsubsection{NFA} % (fold)
	\label{ssub:nfa}
	\paragraph{} % (fold)
	NFA所表示的图中，对其中某个$V_N$，$(edge, target)$并非一一对应。
	% paragraph  (end)
	\begin{lstlisting}
	struct nfa_node
	{
	//long vis;
	long id;
	vector<list_node> out_edge;
	int push_back(list_node node)
	{
	out_edge.push_back(node);
	return 0;
	}
	};
	\end{lstlisting}
	% subsubsection nfa (end)
	\subsubsection{DFA} % (fold)
	\label{ssub:dfa}
	\paragraph{} % (fold)
	DFA中，对其中某个$V_N$，$(edge, target)$一一对应。
	% paragraph  (end)
	\begin{lstlisting}
	struct dfa_node
	{
	long flag;
	long state_id;
	vector<list_node> out_edge;
	int push_back(list_node node)
	{
	this->out_edge.push_back(node);
	return 0;
	}
	};
	\end{lstlisting}
	% subsubsection dfa (end)
	\subsubsection{LR Production} % (fold)
	\label{ssub:lr_production}
	\paragraph{} % (fold)
	LR中，对一条产生式$A \rightarrow aSbCd$，将右部存在vector<string>
	（production）中，而其左部为唯一确定的$V_N$，则用编号唯一表示，
	为便于遍历以某一$V_N$为左部的所有产生式（即对一个LR项目集求闭包），不妨
	用vector<production>存储以某一$V_N$为左部的所有产生式。
	% paragraph  (end)
	% subsubsection lr_production (end)
	\subsubsection{LR DFA Node} % (fold)
	\label{ssub:lr_dfa_node}
	\paragraph{} % (fold)
	在依据LR(1)分析法所构造的识别活前缀的DFA中，每个$V_N$代表着
	\begin{enumerate}
		\item 产生式的集合，每一条产生式右部的当前指针；
		\item 跟在每一条产生式之后的first集，又称后跟符号集。
	\end{enumerate}
	% paragraph  (end)
	\paragraph{} % (fold)
	为实现STL中的find、sort算法，重载operator<、operator==。
	% paragraph  (end)
	\begin{lstlisting}
	struct lr_dfa_node
	{
	long vn_id;
	long production_id;
	long pointer; // point to the right component S -> •aAbBc
	set<string> first_s;
	
	bool operator<(const lr_dfa_node& r) const
	{
	if(vn_id < r.vn_id)
	return true;
	if(vn_id == r.vn_id && production_id < r.production_id)
	return true;
	if(vn_id == r.vn_id && production_id == r.production_id &&
	pointer < r.pointer)
	return true;
	if(vn_id == r.vn_id && production_id == r.production_id &&
	pointer == r.pointer && first_s < r.first_s)
	return true;
	return false;
	}
	
	bool operator==(const lr_dfa_node& r) const
	{
	return (vn_id == r.vn_id && production_id == r.production_id &&
	pointer == r.pointer && first_s == r.first_s);
	//return true;
	}
	};
	\end{lstlisting}
	% subsubsection lr_dfa_node (end)
	% subsection data_structure (end)
	% section grammar_modify_and_data_structure (end)
	
	\section{实现算法} % (fold)
	\label{sec:algorithm}
	\subsection{转化NFA到DFA} % (fold)
	\label{sub:nfa_to_dfa}
	\paragraph{} % (fold)
	将从起始状态拓展的所有状态放入vector<dfa\_node>中，
	对每个状态继续拓展直至状态数不再增多。
	% paragraph  (end)
	\begin{algorithm}
		\caption{转化NFA为DFA}
		\begin{algorithmic}[1] % 显示行号
			\Require $NFA\quad Graph$
			\Ensure $DFA\quad Graph$
			\Function {nfa2dfa}{$nfa\_graph$}
			\State $i \gets 0$
			\State $dfa.push_back(Move_{\epsilon}(S))$
			\While{$i < dfa.size()$}
			\For{$j = 0 \to V_T.size()$}
			\State $status \gets Move(dfa[i], V_T[j])$
			\State $status \gets Move_{\epsilon}(status)$
			\If{$status \notin dfa$}
			\State $dfa.push\_back(status)$
			\EndIf
			\State $dfa[i][V_T[j]] \gets status$
			\EndFor
			\State $i++$
			\EndWhile
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
	% subsection nfa_to_dfa (end)
	\subsection{求$V_N \rightarrow \varepsilon$的$V_N$集合} % (fold)
	\label{sub:solve_epsilon}
	\paragraph{} % (fold)
	如书上，置所有$V_N$的状态为Undefined，第一步求出所有直接
	推导出$\varepsilon$或非空的状态，记为Yes/No；第二步对每
	个Undefined的$V_N$扫描其所有右部，扫描至所有$V_N$为Yes/
	No为止。书上删除产生式或某个右部非终结符在实际编程中并不适用，
	故采用标记法，记录每条产生式的状态，如$V_N$一样Yes/Undefined/No。
	% paragraph  (end)
	\begin{algorithm}
		\caption{求$V_N \rightarrow \varepsilon$的$V_N$集合}
		\begin{algorithmic}[1] % 显示行号
			\Require Productions
			\Ensure $V_N\quad Set$
			\Function {solve\_epsilon}{produc}
			\State $memset(Flag, Undefined, V_N.size())$
			\State $change\_flag \gets true$
			\While{$change\_flag$}
			\State $change\_flag \gets false$
			\For{$i = 0 \to V_N.size()$}
			\If{$Flag[V_N[i]]!=Undefined$}
			\State continue;
			\EndIf
			\State $not\_count \gets 0$
			\For{$j = 0 \to produc[V_N[i]].size()$}
			\If{$Kind(produc[V_N[i]][j])== Yes$}
			\State $Flag[V_N[i]] \gets Yes$
			\State $change\_flag \gets true$
			\State break
			\ElsIf{$Kind(produc[V_N[i]][j])==No$}
			\State $not\_count++$
			\State continue
			\Else
			\State continue
			\EndIf
			\EndFor
			\If{$Flag[V_N[i]]==Undefined \textbf{and} not\_count==produc[V_N[i]].size()$}
			\State $Flag[V_N[i]] \gets No$
			\State $change\_flag \gets true$
			\EndIf
			\EndFor
			\EndWhile
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
	% subsection subsection_name (end)
	\subsection{求每一个$V_N$的First集} % (fold)
	\label{sub:solve_first}
	\paragraph{} % (fold)
	如书上，扫描$V_N$的每条产生式，若$A \rightarrow \varepsilon$，
	则跳过；若$A \rightarrow a$，则$a \in First(A)$；若
	$A \rightarrow B\beta$，则$First(B) \subset First(A)$，此
	时若$B \Rightarrow^{*} \varepsilon$，则$First(\beta) \subset First(A)$。
	重复扫描，直至所有$V_N$的first集不再增大为止。
	% paragraph  (end)
	\begin{algorithm}
		\caption{求每一个$V_N$的First集}
		\begin{algorithmic}[1] % 显示行号
			\Require Productions, $Epsilon_{V_N}$
			\Ensure First Set
			\Function {solve\_first}{produc, $epsilon_{V_N}$}
			\State $expand\_flag \gets true$
			\While{$expand\_flag$}
			\State $expand\_flag \gets false$
			\For{$i = 0 \to V_N.size()$}
			\State $pre\_size \gets first[V_N[i]].size()$
			\For{$j = 0 \to produc[V_N[i]].size()$}
			\State $first[V_N[i]] \gets First(produc[V_N[i]]) \cup first[V_N[i]]$
			\EndFor
			\If{$pre\_size < first[V_N[i]].size()$}
			\State $expand\_flag \gets true$
			\EndIf
			\EndFor
			\EndWhile
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
	% subsection subsection_name (end)
	\subsection{用LR(1)分析法构造可识别活前缀的DFA} % (fold)
	\label{sub:lr_dfa}
	\paragraph{} % (fold)
	实际上，LR(1)与LR(0)的项目集构造并无区别，只有first集提高了
	LR(1)的识别能力与接受文法的能力。先求$CLOSURE(I)$，再求$GOTO(I, X)$，
	并对每一项$J \leftarrow GOTO(I, X)$求$CLOSURE(J)$。
	% paragraph  (end)
	\begin{algorithm}
		\caption{用LR(1)分析法构造可识别活前缀的DFA}
		\begin{algorithmic}[1] % 显示行号
			\Require Productions
			\Ensure DFA Graph
			\Function {lr\_graph}{produc}
			\State $i \gets 0$
			\State $dfa.push\_back(CLOSURE(S'))$
			\State $set \gets V_N \cup V_T$
			\While{$i < dfa.size()$}
			\For{$j = 0 \to set.size()$}
			\State $node \gets GOTO(dfa[i], set[j])$
			\State $node \gets CLOSURE(node)$
			\If{$node \notin dfa$}
			\State $dfa.push\_back(node)$
			\EndIf
			\State $dfa[i][set[j]] \gets node$
			\EndFor
			\EndWhile
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
	% subsection lr (end)
	% section _ (end)
	\section{以C语言文法为输入的简单实践} % (fold)
	\label{sec:c_compiler_front}
	\paragraph{} % (fold)
	本C语言子集包含关键字、标识符、界符、运算符、常量，
	关键字写在主程序set中，是标识符的子集；常量分为整数、
	浮点数、科学计数法、字符串；运算符、界符均写在主程序
	set中。
	% paragraph  (end)
	\paragraph{} % (fold)
	待分析源代码：
	% paragraph  (end)
	\begin{lstlisting}
	int main ()
	{
	integer a, b;
	a=3; b=4;
	float c;
	string d;
	if(a - b < 1.0e-6)
	{
	cout << "alessthanb";
	}
	while (a + b > 0)
	{
	cout<<d;
	a--;
	}
	return 0;
	}
	\end{lstlisting}
	\subsection{词法分析器} % (fold)
	\label{sub:c_lexical_analyzier}
	\paragraph{} % (fold)
	如图，输出的单词流：
	% paragraph  (end)
	\begin{figure}[htbp] 
		\centering\includegraphics[width=3.5in]{token} 
		\caption{单词表}\label{token:1} 
	\end{figure}
	% subsection _ (end)
	\subsection{语法分析器} % (fold)
	\label{sub:c_grammar_analyzier}
	\paragraph{} % (fold)
	如图，分析栈：
	% paragraph  (end)
	\begin{figure}[htbp] 
		\centering\includegraphics[width=3.5in]{stack} 
		\caption{分析栈}\label{stack:1} 
	\end{figure}
	% subsection _ (end)
	% section _c_ (end)
	\section{数据结构改进的思考与LR(1)的不足} % (fold)
	\label{sec:_lr}
	\paragraph{} % (fold)
	在编程过程中发现，对于词法/语法分析器的处理关键主要在于
	查找与去重，因此采用C++ STL中以红黑树为实现的set、multimap
	来作为nfa、dfa、first、lr\_dfa的数据结构是十分合适的。
	% paragraph  (end)
	除去查找与去重的便利外，对迭代器接口的实现使得遍历十分容易，
	此时就使得编程从繁冗的工作中脱离出来，只需要考虑迭代时当前
	的元素。此外，在遍历时对于算法的优化对时间的减少也十分可观，
	比如 $MOVE(I, X)$ 可以在一次遍历中完成 $target$ 核的计算。
	% paragraph  (end)
	\paragraph{} % (fold)
	本次课程设计做的是通用三型/二型文法的解析与匹配工作，因此
	相比于手工构造目标语言的解析器，大部分时间工作效率十分低下，
	而且对于匹配的某些情况可能会出错，比如C++11的“>>”问题。
	% paragraph  (end)
	\paragraph{} % (fold)
	在最后对于C语言子集文法的适配中，LR(1)的解析力并不如想象中
	优秀，依然出现了一些归约-归约冲突/移进-归约冲突，而对于更
	深层次非LR(1)文法的改造并未学习，甚为遗憾。
	% paragraph  (end)
	% section _lr (end)
\end{document}